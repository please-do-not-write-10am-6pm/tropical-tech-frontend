{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { UnavailabilityError } from 'expo-modules-core';\nimport invariant from 'invariant';\nimport ExpoLocalAuthentication from \"./ExpoLocalAuthentication\";\nimport { AuthenticationType, SecurityLevel } from \"./LocalAuthentication.types\";\nexport { AuthenticationType, SecurityLevel };\nexport function hasHardwareAsync() {\n  return _regeneratorRuntime.async(function hasHardwareAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (ExpoLocalAuthentication.hasHardwareAsync) {\n            _context.next = 2;\n            break;\n          }\n\n          throw new UnavailabilityError('expo-local-authentication', 'hasHardwareAsync');\n\n        case 2:\n          _context.next = 4;\n          return _regeneratorRuntime.awrap(ExpoLocalAuthentication.hasHardwareAsync());\n\n        case 4:\n          return _context.abrupt(\"return\", _context.sent);\n\n        case 5:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function supportedAuthenticationTypesAsync() {\n  return _regeneratorRuntime.async(function supportedAuthenticationTypesAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          if (ExpoLocalAuthentication.supportedAuthenticationTypesAsync) {\n            _context2.next = 2;\n            break;\n          }\n\n          throw new UnavailabilityError('expo-local-authentication', 'supportedAuthenticationTypesAsync');\n\n        case 2:\n          _context2.next = 4;\n          return _regeneratorRuntime.awrap(ExpoLocalAuthentication.supportedAuthenticationTypesAsync());\n\n        case 4:\n          return _context2.abrupt(\"return\", _context2.sent);\n\n        case 5:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function isEnrolledAsync() {\n  return _regeneratorRuntime.async(function isEnrolledAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          if (ExpoLocalAuthentication.isEnrolledAsync) {\n            _context3.next = 2;\n            break;\n          }\n\n          throw new UnavailabilityError('expo-local-authentication', 'isEnrolledAsync');\n\n        case 2:\n          _context3.next = 4;\n          return _regeneratorRuntime.awrap(ExpoLocalAuthentication.isEnrolledAsync());\n\n        case 4:\n          return _context3.abrupt(\"return\", _context3.sent);\n\n        case 5:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getEnrolledLevelAsync() {\n  return _regeneratorRuntime.async(function getEnrolledLevelAsync$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          if (ExpoLocalAuthentication.getEnrolledLevelAsync) {\n            _context4.next = 2;\n            break;\n          }\n\n          throw new UnavailabilityError('expo-local-authentication', 'getEnrolledLevelAsync');\n\n        case 2:\n          _context4.next = 4;\n          return _regeneratorRuntime.awrap(ExpoLocalAuthentication.getEnrolledLevelAsync());\n\n        case 4:\n          return _context4.abrupt(\"return\", _context4.sent);\n\n        case 5:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function authenticateAsync() {\n  var options,\n      promptMessage,\n      result,\n      _args5 = arguments;\n  return _regeneratorRuntime.async(function authenticateAsync$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          options = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {};\n\n          if (ExpoLocalAuthentication.authenticateAsync) {\n            _context5.next = 3;\n            break;\n          }\n\n          throw new UnavailabilityError('expo-local-authentication', 'authenticateAsync');\n\n        case 3:\n          if (options.hasOwnProperty('promptMessage')) {\n            invariant(typeof options.promptMessage === 'string' && options.promptMessage.length, 'LocalAuthentication.authenticateAsync : `options.promptMessage` must be a non-empty string.');\n          }\n\n          promptMessage = options.promptMessage || 'Authenticate';\n          _context5.next = 7;\n          return _regeneratorRuntime.awrap(ExpoLocalAuthentication.authenticateAsync(_objectSpread(_objectSpread({}, options), {}, {\n            promptMessage: promptMessage\n          })));\n\n        case 7:\n          result = _context5.sent;\n\n          if (result.warning) {\n            console.warn(result.warning);\n          }\n\n          return _context5.abrupt(\"return\", result);\n\n        case 10:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function cancelAuthenticate() {\n  return _regeneratorRuntime.async(function cancelAuthenticate$(_context6) {\n    while (1) {\n      switch (_context6.prev = _context6.next) {\n        case 0:\n          if (ExpoLocalAuthentication.cancelAuthenticate) {\n            _context6.next = 2;\n            break;\n          }\n\n          throw new UnavailabilityError('expo-local-authentication', 'cancelAuthenticate');\n\n        case 2:\n          _context6.next = 4;\n          return _regeneratorRuntime.awrap(ExpoLocalAuthentication.cancelAuthenticate());\n\n        case 4:\n        case \"end\":\n          return _context6.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}","map":{"version":3,"mappings":";;;;;;;AAAA,SAASA,mBAAT,QAAoC,mBAApC;AACA,OAAOC,SAAP,MAAsB,WAAtB;AAEA,OAAOC,uBAAP;AACA,SAEEC,kBAFF,EAIEC,aAJF;AAOA,SAAqCD,kBAArC,EAAoFC,aAApF;AAQA,OAAO,SAAeC,gBAAf;EAAA;IAAA;MAAA;QAAA;UAAA,IACAH,uBAAuB,CAACG,gBADxB;YAAA;YAAA;UAAA;;UAAA,MAEG,IAAIL,mBAAJ,CAAwB,2BAAxB,EAAqD,kBAArD,CAFH;;QAAA;UAAA;UAAA,iCAIQE,uBAAuB,CAACG,gBAAxB,EAJR;;QAAA;UAAA;;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA;AAAA;AAeP,OAAO,SAAeC,iCAAf;EAAA;IAAA;MAAA;QAAA;UAAA,IACAJ,uBAAuB,CAACI,iCADxB;YAAA;YAAA;UAAA;;UAAA,MAEG,IAAIN,mBAAJ,CAAwB,2BAAxB,EAAqD,mCAArD,CAFH;;QAAA;UAAA;UAAA,iCAIQE,uBAAuB,CAACI,iCAAxB,EAJR;;QAAA;UAAA;;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA;AAAA;AAaP,OAAO,SAAeC,eAAf;EAAA;IAAA;MAAA;QAAA;UAAA,IACAL,uBAAuB,CAACK,eADxB;YAAA;YAAA;UAAA;;UAAA,MAEG,IAAIP,mBAAJ,CAAwB,2BAAxB,EAAqD,iBAArD,CAFH;;QAAA;UAAA;UAAA,iCAIQE,uBAAuB,CAACK,eAAxB,EAJR;;QAAA;UAAA;;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA;AAAA;AAeP,OAAO,SAAeC,qBAAf;EAAA;IAAA;MAAA;QAAA;UAAA,IACAN,uBAAuB,CAACM,qBADxB;YAAA;YAAA;UAAA;;UAAA,MAEG,IAAIR,mBAAJ,CAAwB,2BAAxB,EAAqD,uBAArD,CAFH;;QAAA;UAAA;UAAA,iCAIQE,uBAAuB,CAACM,qBAAxB,EAJR;;QAAA;UAAA;;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA;AAAA;AAiBP,OAAO,SAAeC,iBAAf;EAAA;EAAA;EAAA;EAAA;EAAA;IAAA;MAAA;QAAA;UACLC,OADK,8DACiC,EADjC;;UAAA,IAGAR,uBAAuB,CAACO,iBAHxB;YAAA;YAAA;UAAA;;UAAA,MAIG,IAAIT,mBAAJ,CAAwB,2BAAxB,EAAqD,mBAArD,CAJH;;QAAA;UAOL,IAAIU,OAAO,CAACC,cAAR,CAAuB,eAAvB,CAAJ,EAA6C;YAC3CV,SAAS,CACP,OAAOS,OAAO,CAACE,aAAf,KAAiC,QAAjC,IAA6CF,OAAO,CAACE,aAAR,CAAsBC,MAD5D,EAEP,6FAFO,CAAT;UAID;;UAEKD,aAdD,GAciBF,OAAO,CAACE,aAAR,IAAyB,cAd1C;UAAA;UAAA,iCAegBV,uBAAuB,CAACO,iBAAxB,iCAA+CC,OAA/C;YAAwDE,aAAa,EAAbA;UAAxD,GAfhB;;QAAA;UAeCE,MAfD;;UAiBL,IAAIA,MAAM,CAACC,OAAX,EAAoB;YAClBC,OAAO,CAACC,IAAR,CAAaH,MAAM,CAACC,OAApB;UACD;;UAnBI,kCAoBED,MApBF;;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA;AAAA;AA2BP,OAAO,SAAeI,kBAAf;EAAA;IAAA;MAAA;QAAA;UAAA,IACAhB,uBAAuB,CAACgB,kBADxB;YAAA;YAAA;UAAA;;UAAA,MAEG,IAAIlB,mBAAJ,CAAwB,2BAAxB,EAAqD,oBAArD,CAFH;;QAAA;UAAA;UAAA,iCAICE,uBAAuB,CAACgB,kBAAxB,EAJD;;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA;AAAA","names":["UnavailabilityError","invariant","ExpoLocalAuthentication","AuthenticationType","SecurityLevel","hasHardwareAsync","supportedAuthenticationTypesAsync","isEnrolledAsync","getEnrolledLevelAsync","authenticateAsync","options","hasOwnProperty","promptMessage","length","result","warning","console","warn","cancelAuthenticate"],"sourceRoot":"","sources":["../src/LocalAuthentication.ts"],"sourcesContent":["import { UnavailabilityError } from 'expo-modules-core';\nimport invariant from 'invariant';\n\nimport ExpoLocalAuthentication from './ExpoLocalAuthentication';\nimport {\n  LocalAuthenticationOptions,\n  AuthenticationType,\n  LocalAuthenticationResult,\n  SecurityLevel,\n} from './LocalAuthentication.types';\n\nexport { LocalAuthenticationOptions, AuthenticationType, LocalAuthenticationResult, SecurityLevel };\n\n// @needsAudit\n/**\n * Determine whether a face or fingerprint scanner is available on the device.\n * @return Returns a promise which fulfils with a `boolean` value indicating whether a face or\n * fingerprint scanner is available on this device.\n */\nexport async function hasHardwareAsync(): Promise<boolean> {\n  if (!ExpoLocalAuthentication.hasHardwareAsync) {\n    throw new UnavailabilityError('expo-local-authentication', 'hasHardwareAsync');\n  }\n  return await ExpoLocalAuthentication.hasHardwareAsync();\n}\n\n// @needsAudit\n/**\n * Determine what kinds of authentications are available on the device.\n * @return Returns a promise which fulfils to an array containing [`AuthenticationType`s](#authenticationtype).\n *\n * Devices can support multiple authentication methods- i.e. `[1,2]` means the device supports both\n * fingerprint and facial recognition. If none are supported, this method returns an empty array.\n */\nexport async function supportedAuthenticationTypesAsync(): Promise<AuthenticationType[]> {\n  if (!ExpoLocalAuthentication.supportedAuthenticationTypesAsync) {\n    throw new UnavailabilityError('expo-local-authentication', 'supportedAuthenticationTypesAsync');\n  }\n  return await ExpoLocalAuthentication.supportedAuthenticationTypesAsync();\n}\n\n// @needsAudit\n/**\n * Determine whether the device has saved fingerprints or facial data to use for authentication.\n * @return Returns a promise which fulfils to `boolean` value indicating whether the device has\n * saved fingerprints or facial data for authentication.\n */\nexport async function isEnrolledAsync(): Promise<boolean> {\n  if (!ExpoLocalAuthentication.isEnrolledAsync) {\n    throw new UnavailabilityError('expo-local-authentication', 'isEnrolledAsync');\n  }\n  return await ExpoLocalAuthentication.isEnrolledAsync();\n}\n\n// @needsAudit\n/**\n * Determine what kind of authentication is enrolled on the device.\n * @return Returns a promise which fulfils with [`SecurityLevel`](#securitylevel).\n * > **Note:** On Android devices prior to M, `SECRET` can be returned if only the SIM lock has been\n * enrolled, which is not the method that [`authenticateAsync`](#localauthenticationauthenticateasyncoptions)\n * prompts.\n */\nexport async function getEnrolledLevelAsync(): Promise<SecurityLevel> {\n  if (!ExpoLocalAuthentication.getEnrolledLevelAsync) {\n    throw new UnavailabilityError('expo-local-authentication', 'getEnrolledLevelAsync');\n  }\n  return await ExpoLocalAuthentication.getEnrolledLevelAsync();\n}\n\n// @needsAudit\n/**\n * Attempts to authenticate via Fingerprint/TouchID (or FaceID if available on the device).\n * > **Note:** Apple requires apps which use FaceID to provide a description of why they use this API.\n * If you try to use FaceID on an iPhone with FaceID without providing `infoPlist.NSFaceIDUsageDescription`\n * in `app.json`, the module will authenticate using device passcode. For more information about\n * usage descriptions on iOS, see [Deploying to App Stores](/distribution/app-stores#system-permissions-dialogs-on-ios).\n * @param options\n * @return Returns a promise which fulfils with [`LocalAuthenticationResult`](#localauthenticationresult).\n */\nexport async function authenticateAsync(\n  options: LocalAuthenticationOptions = {}\n): Promise<LocalAuthenticationResult> {\n  if (!ExpoLocalAuthentication.authenticateAsync) {\n    throw new UnavailabilityError('expo-local-authentication', 'authenticateAsync');\n  }\n\n  if (options.hasOwnProperty('promptMessage')) {\n    invariant(\n      typeof options.promptMessage === 'string' && options.promptMessage.length,\n      'LocalAuthentication.authenticateAsync : `options.promptMessage` must be a non-empty string.'\n    );\n  }\n\n  const promptMessage = options.promptMessage || 'Authenticate';\n  const result = await ExpoLocalAuthentication.authenticateAsync({ ...options, promptMessage });\n\n  if (result.warning) {\n    console.warn(result.warning);\n  }\n  return result;\n}\n\n// @needsAudit\n/**\n * **(Android Only)** Cancels authentication flow.\n */\nexport async function cancelAuthenticate(): Promise<void> {\n  if (!ExpoLocalAuthentication.cancelAuthenticate) {\n    throw new UnavailabilityError('expo-local-authentication', 'cancelAuthenticate');\n  }\n  await ExpoLocalAuthentication.cancelAuthenticate();\n}\n"]},"metadata":{},"sourceType":"module"}